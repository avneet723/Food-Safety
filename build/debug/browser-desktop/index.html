<!DOCTYPE html><html><head><title>food-safety</title><style>html, body { height: 100%; background: #000; }
html, body, ul, ol, li, form, fieldset, legend { margin: 0; padding: 0; }
div { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; -ms-box-sizing: border-box; }
h1, h2, h3, h4, h5, h6, p { margin-top: 0; }
fieldset, img { border: 0; }
legend { color: #000; }
li { list-style: none; }
sup { vertical-align: text-top; }
sub { vertical-align: text-bottom; }
table { border-collapse: collapse; border-spacing: 0; }
caption, th, td { text-align: left; vertical-align: top; font-weight: normal; }
input, textarea, select { font-size: 110%; line-height: 1.1; }
abbr, acronym { border-bottom: .1em dotted; cursor: help; }
body { font-family: Helvetica, Tahoma; }
body, div, span {
	-webkit-tap-highlight-color: rgba(0,0,0,0);
	-webkit-user-select: none;
}
</style></head><body></body><script>IMG_CACHE={};;(function() {
window.BUILD_TARGET="browser-desktop";
window.BUILD_ENV="browser";
window.DEBUG=true;
window.DEV_MODE=true;
window.ADDON_EXAMPLES=true;
window.CONFIG={"appID":"49e4e92ebbd148d5ae0be388d430ed0a","shortName":"food-safety","title":"food-safety","disableNativeViews":false,"target":"browser-desktop","version":1363295873773,"servicesURL":"http://staging.api.gameclosure.com","noRedirect":true,"inviteURLTemplate":"http://172.31.53.118:9200/simulate/food-safety/browser-desktop/?i={code}","preload":{"autoHide":true,"img":"preload/splash.png","iphone":{"launch":"preload/iphone/Default.png","launchRetina":"preload/iphone/Default@2x.png","launchRetina4":"preload/iphone/Default-568h@2x.png"},"ipad":{"portrait":"preload/ipad/Default-Portrait~ipad.png","portraitRetina":"preload/ipad/Default-Portrait@2x~ipad.png","landscape":"preload/ipad/Default-Landscape~ipad.png","landscapeRetina":"preload/ipad/Default-Landscape@2x~ipad.png"}},"sdkVersion":"unknown"};
window.CONFIG.baseURL = window.location.toString().match(/(.*\/).*$/)[1];
})();;function bootstrap(initialImport, target) {
	var w = window;
	var d = document;
	var loc = w.location;
	var q = loc.search + loc.hash;

	// check to see if we need chrome frame
	if (target && (target=="desktop" || target=="facebook") && /MSIE/i.test(navigator.userAgent) && !d.createElement('canvas').getContext) {
		var chromeframe_url = 'chromeframe.html' + (loc.search ? loc.search + "&" : "?") + "target="+ target;
		bootstrap = function() {};
		try {
			var obj = new ActiveXObject('ChromeTab.ChromeFrame');
			if (!obj) {
				throw "bad object";
			}
			loc.replace(chromeframe_url);
		} catch(e) {
			w.onload = function() {
				var e = d.createElement('script'); 
				e.async = true;
			    e.src = "http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js";
				e.onreadystatechange= function () {
					if (this.readyState == 'loaded') {
						CFInstall.check({
							mode: "overlay",
							oninstall: function() { loc.replace(chromeframe_url) },
							url: "http://www.google.com/chromeframe/eula.html?user=true"
						});
					}
				}
				d.getElementsByTagName('head')[0].appendChild(e);
			}
		}
		return;
	}
	
	// for tracking when the page started loading
	w.__initialTime = +new Date();

	try {
		// override any config params provided already
		if (w.CONFIG_OVERRIDES) {
			for (var key in w.CONFIG_OVERRIDES) {
				w.CONFIG[key] = w.CONFIG_OVERRIDES[key];
			}
		}

		var uri = decodeURIComponent((w.location.search || '?').substr(1));
		if (uri[0] == '{') {
			// override any config params in the URL
			var overrideCONFIG = JSON.parse(uri);
			if (overrideCONFIG) {
				for (var key in overrideCONFIG) {
					w.CONFIG[key] = overrideCONFIG[key];
				}
			}
		}
	} catch(e) {
		
	}
	
	if (w.CONFIG.CDNURL) {
		d.write('<base href="' + w.CONFIG.CDNURL + '">');
	}
	
	// figure out the dpr
	if (w.CONFIG.scaleDPR === false) {
		var scale = 1;
	} else {
		var scale = (1 / (w.devicePixelRatio || 1));
	}

	// figure out the device type
	var ua = navigator.userAgent;
	var mobile = (/(iPod|iPhone|iPad)/i.test(ua) ? 'ios' : /BlackBerry/.test(ua) ? 'blackberry' : /Mobile Safari/.test(ua) ? 'android' : '');

	if (loc.search.match(/exportSettings=true/)) {
		// just export localStorage
		exportSettings();
	} else if (mobile != 'blackberry' && !w.CONFIG.noRedirect) {
		// redirect based on device
		if (mobile && target != 'browser-mobile') {
			return loc.replace('//' + loc.host + '/browser-mobile/' + loc.hash);
		} else if (!mobile && target == 'browser-mobile') {
			return loc.replace('//' + loc.host + '/browser-desktop/' + loc.hash);
		}
	}
	
	// set the viewport
	if (mobile == 'ios') {
		// Using initial-scale on android makes everything blurry! I think only IOS
		// correctly uses devicePixelRatio.  Medium/high-res android seems to set
		// the dpr to 1.5 across the board, regardless of what the dpr should actually
		// be...
		d.write('<meta name="viewport" content="'
				+ 'user-scalable=no'
				+ ',initial-scale=' + scale
				+ ',maximum-scale=' + scale
				+ ',minimum-scale=' + scale
				+ ',width=device-width'
			+ '" />');
	}
	
	if (!Image.get) {
		Image.set = function(url, img) { CACHE[url] = img; };
		Image.get = function(url) { return CACHE[url]; };
	}
	
	w.hideAddressBar = function() {
		if (!mobile) { return; }
		
		d.body.style.height = 2 * screen.height + 'px';
		if (mobile == 'ios') {
			w.scrollTo(0, 1);
			w.scrollTo(0, 0);
		} else {
			w.scrollTo(0, 1);
		}
		d.body.offsetHeight;
	}

	hideAddressBar();
	var min = w.innerHeight;

	var loaded = false;
	w._continueLoad = function() {
		if (!loaded) {
			loaded = true;
			var el = d.createElement('script');
			el.src = target + '.js';
			d.getElementsByTagName('head')[0].appendChild(el);
		}
	};

	// after load, we poll for the correct document height
	w.onload = function() {
		var now = +new Date();
		var increased = false;
		var poll = setInterval(function() {
			hideAddressBar();
			var h = w.innerHeight;
			
			// timeout after 100ms and assume we have the right height, or 
			// note when the height increases (we scrolled) and launch the app
			if (h == min && increased || +new Date() - now > 1000) {
				if (mobile == 'android') {
					w.scrollTo(0, -1);
				}

				clearInterval(poll);

				setTimeout(function () {
					jsio("import gc.browser.bootstrap.launchBrowser");
				}, 0);
			}

			// some android phones report correctly first, then shrink the height
			// to fit the address bar. always reset min
			if (h > min) { increased = true; }
			min = h;
		}, 50);
	}
}
;bootstrap('gc.browser.launchClient', 'browser-desktop');// Copyright (c) 2010
// Michael Carter (cartermichael@gmail.com)
// Martin Hunt (mghunt@gmail.com)
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Initialization of js.io occurs in a closure, preventing local variables
// from entering the global scope.  During execution, the method `jsio` is
// added to the global scope.

;(function() {
	function init(cloneFrom) {
		// We expect this code to be minified before production use, so we may
		// write code slightly more verbosely than we otherwise would.
	
		// Should we parse syntax errors in the browser?
		var DEBUG = true;
	
		// Store a reference to the slice function for converting objects of
		// type arguments to type array.
		var SLICE = Array.prototype.slice;
	
		// js.io supports multiple JavaScript environments such as node.js and
		// most web browsers (IE, Firefox, WebKit).  The ENV object wraps 
		// any utility functions that contain environment-specific code (e.g.
		// reading a file using node's `fs` library or a browser's
		// `XMLHttpRequest`).  Running js.io in other JavaScript environments
		// is as easy as implementing an environment object that conforms to 
		// the abstract interface for an environment (provided below) and 
		// calling `jsio.setEnv()`.
		var ENV;
	
		// Checks if the last character in a string is `/`.
		var rexpEndSlash = /\/|\\$/;

		function getModuleDef (path) {
			path += '.js';
			return jsio.__modules[path] || new ModuleDef(path);
		}
	
		// Creates an object containing metadata about a module.
		function ModuleDef (path) {
			this.path = path;
			this.friendlyPath = path;
			util.splitPath(path, this);
		};

		ModuleDef.prototype.setBase = function (baseMod, basePath) {
			this.baseMod = baseMod;
			this.basePath = basePath;
		};
	
		// Utility functions
		var util = {
				// `util.bind` returns a function that, when called, will execute
				// the method passed in with the provided context and any additional
				// arguments passed to `util.bind`.
				//       util.bind(obj, 'f', a) -> function() { return obj.f(a); }
				//       util.bind(obj, g, a, b, c) -> function() { return g.call(g, a, b, c); }
				bind: function(context, method/*, args... */) {
					var args = SLICE.call(arguments, 2);
					return function() {
						method = (typeof method == 'string' ? context[method] : method);
						return method.apply(context, args.concat(SLICE.call(arguments, 0)));
					};
				},
			
				// `util.addEndSlash` accepts a string.  That string is returned with a `/`
				// appended if the string did not already end in a `/`.
				addEndSlash: function(str) {
					return rexpEndSlash.test(str) ? str : str + '/';
				},
			
				// `util.removeEndSlash` accepts a string.  It removes a trailing `/` if
				// one is found.
				removeEndSlash: function(str) {
					return str.replace(rexpEndSlash, '');
				},
			
				// `util.makeRelativePath` accepts two paths (strings) and returns the first path
				// made relative to the second.  Note: this function needs some work.  It currently
				// handles the most common use cases, but may fail in unexpected edge cases.
				// 
				//  - Simple case: if `path` starts with `relativeTo`, then we can strip `path` 
				// off the `relativeTo` part and we're done.
				//
				//         util.makeRelativePath('abc/def/', 'abc') -> 'def'
				//
				//  - Harder case: `path` starts with some substring of `relativeTo`.  We want to remove this substring and then add `../` for each remaining segment of `relativeTo`.
				//
				//         util.makeRelativePath('abc/def/', 'abc/hij') -> '../def'
				//
				makeRelativePath: function(path, relativeTo) {
					var len = relativeTo.length;
					if (path.substring(0, len) == relativeTo) {
						/* Note: we're casting a boolean to an int by adding len to it */
						return path.slice((path.charAt(len) == ENV.pathSep) + len);
					}
				
					var sA = util.removeEndSlash(path).split(ENV.pathSep),
						sB = util.removeEndSlash(relativeTo).split(ENV.pathSep),
						i = 0;
				
					/* Count how many segments match. */
					while(sA[i] == sB[i]) { ++i; }
				
					if (i) {
						/* If at least some segments matched, remove them.  The result is our new path. */
						path = sA.slice(i).join(ENV.pathSep);
					
						/* Prepend `../` for each segment remaining in `relativeTo`. */
						for (var j = sB.length - i; j > 0; --j) { path = '../' + path; }
					}
				
					return path;
				},
			
				// `buildPath` accepts an arbitrary number of string arguments to concatenate into a path.
				//     util.buildPath('a', 'b', 'c/', 'd/') -> 'a/b/c/d/'
				buildPath: function() {
					var args = Array.prototype.filter.call(arguments, function (x) { return x; });
					return util.resolveRelativePath(args.join('/'));
				},
			
				// `resolveRelativePath` removes relative path indicators.  For example:
				//     util.resolveRelativePath('a/../b') -> b
				resolveRelativePath: function(path) {
					/* If the path starts with a protocol, store it and remove it (add it
					   back later) so we don't accidently modify it. */
					var protocol = path.match(/^(\w+:\/\/)(.*)$/);
					if (protocol) { path = protocol[2]; }
				
					/* Remove multiple slashes and trivial dots (`/./ -> /`). */
					path = path.replace(/\/+/g, '/').replace(/\/\.\//g, '/');
				
					/* Loop to collapse instances of `../` in the path by matching a previous
					   path segment.  Essentially, we find substrings of the form `/abc/../`
					   where abc is not `.` or `..` and replace the substrings with `/`.
					   We loop until the string no longer changes since after collapsing
					   possible instances once, we may have created more instances that can
					   be collapsed.
					*/
					var o;
					while((o = path) != (path = path.replace(/(^|\/)(?!\.?\.\/)([^\/]+)\/\.\.\//g, '$1'))) {}
					/* Don't forget to prepend any protocol we might have removed earlier. */
					return protocol ? protocol[1] + path : path;
				},
			
				resolveRelativeModule: function (modulePath, directory) {
					var result = [],
						parts = modulePath.split('.'),
						len = parts.length,
						relative = (len > 1 && !parts[0]),
						i = relative ? 0 : -1;
				
					while(++i < len) { result.push(parts[i] ? parts[i] : '..'); }
					return util.buildPath(relative ? directory : '', result.join('/'));
				},
				resolveModulePath: function (modulePath, directory) {
					// resolve relative paths
					if (modulePath.charAt(0) == '.') {
						return [getModuleDef(util.resolveRelativeModule(modulePath, directory))];
					}
				
					// resolve absolute paths with respect to jsio packages/
					var pathSegments = modulePath.split('.');
					var baseMod = pathSegments[0];
					var pathString = pathSegments.join('/');
					
					if (jsioPath.cache.hasOwnProperty(baseMod)) {
						return [getModuleDef(util.buildPath(jsioPath.cache[baseMod], pathString))];
					}
				
					var defs = [];
					var paths = jsioPath.get();
					var len = paths.length;
					for (var i = 0; i < len; ++i) {
						var moduleDef = getModuleDef(util.buildPath(paths[i], pathString));
						moduleDef.setBase(baseMod, paths[i]);
						defs.push(moduleDef);
					}
					return defs;
				},
				splitPath: function(path, result) {
					if (!result) { result = {}; }
					var i = path.lastIndexOf('/') + 1;
					result.directory = path.substring(0, i);
					result.filename = path.substring(i);
					return result;
				}
			};
		
		// construct the top-level jsio object
		var jsio = util.bind(this, importer, null, null, null);

		jsio.__util = util;
		jsio.__init__ = init;

		var srcCache;
		jsio.setCache = function(cache) { srcCache = jsio.__srcCache = cache; }
		jsio.setCache(cloneFrom && cloneFrom.__srcCache || {});

		jsio.setCachedSrc = function(path, src) { srcCache[path] = { path: path, src: src }; }
		jsio.getCachedSrc = function(path) { return srcCache[path]; }

		jsio.__filename = 'jsio.js';
		jsio.__cmds = [];
		jsio.__jsio = jsio;
		jsio.__importer = importer;
		jsio.__modules = {preprocessors:{}};
		var jsioPath = {
				set: function(path) { jsioPath.value = (typeof path == 'string' ? [path] : path); },
				get: function() { return jsioPath.value.slice(0); },
				add: function(path) {
					var v = jsioPath.value, len = v.length;
					for (var i = 0; i < len; ++i) {
						if (v[i] == path) { return; }
					}
					v.push(path);
				},
				remove: function(path) {
					var v = jsioPath.value, len = v.length;
					for (var i = 0; i < len; ++i) {
						if (v[i] == path) {
							v.splice(i, 1);
						}
					}
				},
				value: [],
				cache: {}
			};
		
		jsio.path = jsioPath;
		jsio.addPath = util.bind(jsioPath, 'add');
		jsio.addCmd = util.bind(jsio.__cmds, 'push');
		
		jsio.setEnv = function(envCtor) {
			if (!envCtor && cloneFrom) {
				ENV = new cloneFrom.__env.constructor(util);
			} else {
				if (typeof envCtor == 'string') {
					envCtor = ({
							node: ENV_node,
							browser: ENV_browser
						})[envCtor] || ENV_browser;
				}

				ENV = new envCtor(util);
			}

			this.__env = ENV;
			this.__dir = ENV.getCwd();
			this.path.set(ENV.getPath());
		}
		
		if (cloneFrom) {
			jsio.setEnv();
		} else if (typeof process !== 'undefined' && process.version) {
			jsio.setEnv('node');
		} else if (typeof XMLHttpRequest != 'undefined' || typeof ActiveXObject != 'undefined') {
			jsio.setEnv('browser');
		}

		/*
		function ENV_abstract() {
			this.global = null;
			this.getCwd = function() {};
			this.getPath = function() {};
			this.eval = function(code, path) {};
			this.fetch = function(path) { return contentsOfPath; };
			this.log = function(args...) {};
		}
		*/
	
		function ENV_node() {
			var fs = require('fs');
			var path = require('path');
			
			this.name = 'node';
			this.global = GLOBAL;
			this.getCwd = process.cwd;
			this.pathSep = path.sep;

			this.log = function() {
				var msg;
				try {
					msg = Array.prototype.map.call(arguments, function(a) {
							if ((a instanceof Error) && a.message) {
								return 'Error:' + a.message + '\nStack:' + a.stack + '\nArguments:' + a.arguments;
							}
							return (typeof a == 'string' ? a : JSON.stringify(a));
						}).join(' ') + '\n';
				} catch(e) {
					msg = Array.prototype.join.call(arguments, ' ') + '\n';
				}

				process.stderr.write(msg);
				return msg;
			}
			
			this.getPath = function() {
				return path.relative(this.getCwd(), path.dirname(__filename) || '.');
			}
			
			if (process.compile) {
				this.eval = process.compile;
			} else {
				var vm = require('vm');
				this.eval = function (code, path) {
					try {
						return vm.runInThisContext(code, path);
					} catch (e) {
						this.log('In ' + path + ':\n' + e.message);
						throw e;
					}
				}
			}
			
			this.fetch = function (p) {
				p = path.resolve(this.getCwd(), p);

				try {
					var dirname = path.dirname(p);
					var filename = path.basename(p);
					var lowerFilename = filename.toLowerCase();
					var files = fs.readdirSync(dirname);
				} catch (e) {
					return false;
				}

				for (var i = 0, testName; testName = files[i]; ++i) {
					if (testName.toLowerCase() == lowerFilename && testName != filename) {
						throw "Invalid case when importing [" + p + "].  You probably meant" + testName;
					}
				}

				try {
					return fs.readFileSync(p, 'utf8');
				} catch(e) {
					return false;
				}
			}
			
			this.require = require;
		}
	
		function ENV_browser() {
			var XHR = window.XMLHttpRequest || function() { return new ActiveXObject("Msxml2.XMLHTTP"); },
				cwd = null,
				path = null,
				JOIN = Array.prototype.join;
			
			this.name = 'browser';
			this.global = window;
			this.pathSep = "/";

			if (!this.global.jsio) { this.global.jsio = jsio; }
		
			if (window.console && console.log) {
				if (!console.log.apply || /Android|iPhone|iPad|iPod/.test(navigator.userAgent)) {
					this.log = function () {
						var args = JOIN.call(arguments, ' ');
						console.log(args);
						return args;
					}
				} else {
					this.log = function () {
						console.log.apply(console, arguments);
						return JOIN.call(arguments, ' ');
					}
				}
			} else {
				this.log = function () { return JOIN.call(arguments, ' '); }
			}

			this.getCwd = function() {
				if(!cwd) {
					var loc = window.location, path = loc.pathname;
					cwd = loc.protocol + '//' + loc.host + path.substring(0, path.lastIndexOf('/') + 1);
				}
				return cwd;
			}
		
			this.getPath = function() {
				if(!path) {
					try {
						var filename = new RegExp('(.*?)' + jsio.__filename + '(\\?.*)?$'),
							scripts = document.getElementsByTagName('script');
					
						for (var i = 0, script; script = scripts[i]; ++i) {
							var result = script.src.match(filename);
							if (result) {
								path = result[1];
								if (/^[A-Za-z]*:\/\//.test(path)) { path = util.makeRelativePath(path, this.getCwd()); }
								break;
							}
						}
					} catch(e) {}
				
					if(!path) { path = '.'; }
				}
				return path;
			}
		
			this.debugPath = function(path) { return path; }

			// IE6 won't return an anonymous function from eval, so use the function constructor instead
			var rawEval = typeof eval('(function(){})') == 'undefined'
				? function(src, path) { return (new Function('return ' + src))(); }
				: function(src, path) { var src = src + '\n//@ sourceURL=' + path; return window.eval(src); };

			// provide an eval with reasonable debugging
			this.eval = function(code, path, origCode) {
				try {
					return rawEval(code, this.debugPath(path));
				} catch(e) {
					if(e instanceof SyntaxError) {
						ENV.log("a syntax error is preventing execution of " + path);
						if (DEBUG && this.checkSyntax) {
							this.checkSyntax(origCode, path);
						}
					}
					throw e;
				}
			}
		
			this.checkSyntax = function(code, path) {
				try {
					var syntax = jsio('import util.syntax', {suppressErrors: true, dontExport: true}),
						result = syntax(code);
					syntax.display(result, path);
				} catch(e) {}
			}
		
			this.fetch = function(path) {
				var xhr = new XHR();
				try {
					xhr.open('GET', path, false);
					xhr.send(null);
				} catch(e) {
					ENV.log('e:', e);
					return false; // firefox file://
				}
			
				if (xhr.status == 404 || // all browsers, http://
					xhr.status == -1100 || // safari file://
					// XXX: We have no way to tell in opera if a file exists and is empty, or is 404
					// XXX: Use flash?
					//(!failed && xhr.status == 0 && !xhr.responseText && EXISTS)) // opera
					false)
				{
					return false;
				}
			
				return xhr.responseText;
			}
		};
	
		var preprocessorCheck = /^"use (.*?)"\s*;\s*\n/,
			preprocessorFunc = /^(.+)\(.+\)$/,
			failedFetch = {};
	
		function findModule(possibilities, opts) {
			var src;
			for (var i = 0, possible; possible = possibilities[i]; ++i) {
				var path = possible.path,
					cachedVersion = srcCache[path];
				
				if (cachedVersion) {
					possible.src = cachedVersion.src;
					possible.pre = true;
					return possible;
				}
			
				/*if (/^\.\//.test(path)) {
					// remove one path segment for each dot from the cwd 
					path = addEndSlash(ENV.getCwd()) + path;
				}*/
			
				src = ENV.fetch(path);
			
				if (src !== false) {
					possible.src = src;
					return possible;
				} else {
					failedFetch[path] = true;
				}
			}
		
			return false;
		}
	
		// load a module from a file
		function loadModule (fromDir, fromFile, modulePath, opts) {
			var possibilities = util.resolveModulePath(modulePath, fromDir);
			for (var i = 0, p; p = possibilities[i]; ++i) {
				var path = possibilities[i].path;
				if (!opts.reload && (path in jsio.__modules)) {
					return possibilities[i];
				}

				if (path in failedFetch) { possibilities.splice(i--, 1); }
			}
		
			if (!possibilities.length) {
				if (opts.suppressErrors) { return false; }
				var e = new Error('Module failed to load (again)');
				e.jsioLogged = true;
				throw e;
			}
		
			var moduleDef = findModule(possibilities, opts),
				match;
		
			if (!moduleDef) {
				if (opts.suppressErrors) { return false; }
				var paths = [];
				for (var i = 0, p; p = possibilities[i]; ++i) { paths.push(p.path); }
				throw new Error(
					"requested import (" + modulePath + ") not found\n"
					+ "\tlooked in:\n"
						+ "\t\t" + paths.join('\n\t\t') + "\n"
						+ "\tImport Stack:\n"
						+ "\t\t" + importStack.join("\n\t\t"));
			}
		
			// a (potentially) nicer way to refer to a module -- how it was referenced in code when it was first imported
			moduleDef.friendlyPath = modulePath;
			
			// cache the base module's path in the path cache so we don't have to
			// try out all paths the next time we see the same base module.
			if (moduleDef.baseMod && !(moduleDef.baseMod in jsioPath.cache)) {
				jsioPath.cache[moduleDef.baseMod] = moduleDef.basePath;
			}

			// don't apply the standard preprocessors to base.js.  If we're reloading
			// the source code, always apply them.  We also don't want to run them
			// if they've been run once -- moduleDef.pre is set to true already
			// if we're reading the code from the source cache.
			if (modulePath != 'base' && (opts.reload || !opts.dontPreprocess && !moduleDef.pre)) {
				moduleDef.pre = true;

				applyPreprocessors(fromDir, moduleDef, ["import", "cls"], opts);

				// the order here is somewhat arbitrary and might be overly restrictive (... or overly powerful)
				// while (moduleDef.src.charAt(0) == '"' && (match = moduleDef.src.match(preprocessorCheck))) {
				// 	moduleDef.src = moduleDef.src.substring(match[0].length - 1);
				// 	applyPreprocessors(fromDir, moduleDef, match[1].split(','), opts);
				// }
			}

			// any additional preprocessors?
			if (opts.preprocessors) {
				applyPreprocessors(fromDir, moduleDef, opts.preprocessors, opts);
			}

			return moduleDef;
		}
	
		function applyPreprocessors(path, moduleDef, names, opts) {
			for (var i = 0, len = names.length; i < len; ++i) {
				p = getPreprocessor(names[i]);

				// if we have a recursive import and p isn't a function, just
				// skip it (handles the case where a preprocessor imports
				// other modules).
				if (p && typeof p == 'function') {
					p(path, moduleDef, opts);
				}
			}
		}
		
		function getPreprocessor(name) {
			var module = jsio.__modules['preprocessors.' + name];
			return typeof name == 'function'
				? name
				: (module && module.exports
					|| jsio('import preprocessors.' + name, {dontExport: true, dontPreprocess: true}));
		}
	
		function execModuleDef(context, moduleDef) {
			var src = moduleDef.src;
			delete moduleDef.src;

			var code = "(function(_){with(_){delete _;return function $$" + moduleDef.friendlyPath.replace(/[\:\\\/.]/g, '_') + "(){" + src + "\n}}})";
			var fn = ENV.eval(code, moduleDef.path, src);
			fn = fn(context);
			fn.call(context.exports);
		};
		
		function resolveImportRequest(context, request, opts) {
			var cmds = jsio.__cmds,
				imports = [],
				result = false;
		
			for (var i = 0, imp; imp = cmds[i]; ++i) {
				if ((result = imp(context, request, opts, imports))) { break; }
			}
		
			if (result !== true) {
				throw new (typeof SyntaxError != 'undefined' ? SyntaxError : Error)(String(result || 'invalid jsio command: jsio(\'' + request + '\')'));
			}
		
			return imports;
		};
	
		function makeContext(ctx, modulePath, moduleDef, dontAddBase) {
			if (!ctx) { ctx = {}; }
			if (!ctx.exports) { ctx.exports = {}; }

			ctx.jsio = util.bind(this, importer, ctx, moduleDef.directory, moduleDef.filename);
			ctx.require = function(request, opts) {
				if (!opts) { opts = {}; }
				opts.dontExport = true;
				// opts.suppressErrors = true;
				
				try {
					var ret = ctx.jsio(request, opts);
					if (ret === false) {
						// need this to trigger require attempt due to suppresserrors = true
						throw "module failed to load";
					} else {
						return ret;
					}
				} catch(e) {
					ENV.log('Error loading request ' + request + ':');
					ENV.log(e);
				}
			};
			
			ctx.module = {id: modulePath, exports: ctx.exports};
			if (!dontAddBase && modulePath != 'base') {
				ctx.jsio('from base import *', {dontPreprocess: true});
				ctx.logging.__create(modulePath, ctx);
			}
		
			// TODO: FIX for "trailing ." case
			ctx.jsio.__jsio = jsio;
			ctx.jsio.__env = jsio.__env;
			ctx.jsio.__dir = moduleDef.directory;
			ctx.jsio.__filename = moduleDef.filename;
			ctx.jsio.path = jsioPath;
			return ctx;
		};
		
		var importStack = [];
		function importer(boundContext, fromDir, fromFile, request, opts) {
			opts = opts || {};
			fromDir = fromDir || './';
			fromFile = fromFile || '<initial file>';
		
			// importer is bound to a module's (or global) context -- we can override this
			// by using opts.exportInto
			var exportInto = opts.exportInto || boundContext || ENV.global;
		
			// parse the import request(s)
			var imports = resolveImportRequest(exportInto, request, opts),
				numImports = imports.length,
				retVal = numImports > 1 ? {} : null;
		
			// import each requested item
			for (var i = 0; i < numImports; ++i) {
				var item = imports[i];
				var modulePath = item.from;
				var modules = jsio.__modules;
				var path;
				var moduleDef;
				var err;
				
				try {
					moduleDef = loadModule(fromDir, fromFile, modulePath, opts);
				} catch(e) {
					err = e;
				}

				if (moduleDef) {
					path = moduleDef.path;
				} else if (jsio.__env.require) {
					path = modulePath;
					try {
						modules[path] = {exports: jsio.__env.require(modulePath)};
						err = null;
					} catch (e2) {
						if (!err) { err = e2; }
					}
				} else if (moduleDef == false) {
					return false;
				}

				if (err) {
					if (opts.suppressErrors) { return false; }
					if (!err.jsioLogged) {
						ENV.log(
							'\nError loading module:\n',
							'\t[[', request, ']]\n',
							'\trequested by:', fromDir + fromFile, '\n',
							'\tcurrent directory:', jsio.__env.getCwd(), '\n',
							'\t' + err, '\n',
							'\t' + err.stack);
						err.jsioLogged = true;
					}

					throw err;
				}
				
				if (moduleDef) {
					importStack.push(importStack.length + ' : ' + moduleDef.friendlyPath + ' (' + moduleDef.path + ')');
				}
				
				// eval any packages that we don't know about already
				if (!(path in modules)) {
					var newContext = makeContext(opts.context, modulePath, moduleDef, item.dontAddBase);

					modules[path] = moduleDef;

					moduleDef.exports = newContext.exports;
					if (item.dontUseExports) {
						var src = [';(function(){'], k = 1;
						for (var j in item['import']) {
							newContext.exports[j] = undefined;
							src[k++] = 'if(typeof '+j+'!="undefined"&&exports.'+j+'==undefined)exports.'+j+'='+j+';';
						}
						src[k] = '})();';
						moduleDef.src += src.join('');
					}

					execModuleDef(newContext, moduleDef);
					moduleDef.exports = newContext.exports;
				}
				
				importStack.pop();
			
				var module = modules[path].exports;
			
				// return the module if we're only importing one module
				if (numImports == 1) { retVal = module; }
			
				if (!opts.dontExport) {
					// add the module to the current context
					if (item.as) {
						// remove trailing/leading dots
						var as = item.as.match(/^\.*(.*?)\.*$/)[1],
							segments = as.split('.'),
							kMax = segments.length - 1,
							c = exportInto;
				
						// build the object in the context
						for(var k = 0; k < kMax; ++k) {
							var segment = segments[k];
							if (!segment) continue;
							if (!c[segment]) { c[segment] = {}; }
							c = c[segment];
						}
					
						c[segments[kMax]] = module;
				
						// there can be multiple module imports with this syntax (import foo, bar)
						if (numImports > 1) {
							retVal[as] = module;
						}
					} else if (item['import']) {
						// there can only be one module import with this syntax 
						// (from foo import bar), so retVal will already be set here
						if (item['import']['*']) {
							for (var k in modules[path].exports) { exportInto[k] = module[k]; }
						} else {
							for (var k in item['import']) { exportInto[item['import'][k]] = module[k]; }
						}
					}
				}
			}
		
			return retVal;
		}
	
		// DEFINE SYNTAX FOR JSIO('cmd')
	
		// from myPackage import myFunc
		// external myPackage import myFunc
		jsio.addCmd(function(context, request, opts, imports) {
			var match = request.match(/^\s*(from|external)\s+([\w.$]+)\s+(import|grab)\s+(.*)$/);
			if(match) {
				imports.push({
					from: match[2],
					dontAddBase: match[1] == 'external',
					dontUseExports: match[3] == 'grab' || match[1] == 'external',
					'import': {}
				});
			
				match[4].replace(/\s*([\w.$*]+)(?:\s+as\s+([\w.$]+))?/g, function(_, item, as) {
					imports[0]['import'][item] = as || item;
				});
				return true;
			}
		});

		// import myPackage
		jsio.addCmd(function(context, request, opts, imports) {
			var match = request.match(/^\s*import\s+(.*)$/);
			if (match) {
				match[1].replace(/\s*([\w.$]+)(?:\s+as\s+([\w.$]+))?,?/g, function(_, fullPath, as) {
					imports.push(
						as ? {
							from: fullPath,
							as: as
						} : {
							from: fullPath,
							as: fullPath
						});
				});
				return true;
			}
		});

		// CommonJS syntax
		jsio.addCmd(function(context, request, opts, imports) {
		
			//		./../b -> ..b
			// 		../../b -> ...b
			// 		../b -> ..b
			// 		./b -> .b
		
			var match = request.match(/^\s*[\w.0-9$\/\-]+\s*$/);
			if (match) {
			
				var req = util.resolveRelativePath(match[0]),
					isRelative = req.charAt(0) == '.';
			
				req = req
					// .replace(/^\//, '') // remove any leading slash
					.replace(/\.\.\//g, '.') // replace relative path indicators with dots
					.replace(/\.\//g, '')
					.replace(/\//g, '.'); // any remaining slashes are path separators

				imports[0] = { from: (isRelative ? '.' : '') + req };
				return true;
			}
		});
		
		jsio.install = function() {
			jsio('from base import *');
			GLOBAL['logger'] = logging.get('jsiocore');
		};

		jsio.eval = function (src, path) {
			path = ENV.getCwd() || '/';
			var moduleDef = new ModuleDef(path);
			moduleDef.src = src;
			applyPreprocessors(path, moduleDef, ["import", "cls"], {});
			execModuleDef(ENV.global, moduleDef);
		};
		
		jsio.clone = util.bind(null, init, jsio);

		return jsio;
	}

	var J = init(null, {});
	if (typeof exports != 'undefined') {
		module.exports = J;
	} else {
		jsio = J;
	}
})();
jsio.path.set(["sdk/jsio",".","sdk/gc/api/","sdk/","sdk/timestep/"]);jsio.path.cache={"preprocessors":"sdk/jsio","base":"sdk/jsio","util":"sdk/jsio","gc":"sdk/","lib":"sdk/jsio"};jsio.setCache({"sdk/jsio/base.js":{"path":"sdk/jsio/base.js","friendlyPath":"base","directory":"sdk/jsio/","filename":"base.js","baseMod":"base","basePath":"sdk/jsio","src":"/**\n * base.js\n * This file contains all global functions provided by js.io.\n */\n\nexports.log = jsio.__env.log;\nexports.GLOBAL = jsio.__env.global;\n\n/**\n * Various polyfill methods to ensure js.io implementations provide\n * a baseline of JavaScript functionality. Feature compatibility (localStorage,\n * etc.) should be provided elsewhere.\n */\n\n// Array.isArray\n// Not available before ECMAScript 5.\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray\n\nif (!Array.isArray) {\n\tArray.isArray = function (arg) {\n\t\treturn Object.prototype.toString.call(arg) === '[object Array]';\n\t}\n};\n\n// Function.prototype.bind\n// Not available before ECMAScript 5.\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind\n\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function (oThis) {\n    if (typeof this !== \"function\") {\n      // closest thing possible to the ECMAScript 5 internal IsCallable function\n      throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n    }\n\n    var aArgs = Array.prototype.slice.call(arguments, 1), \n        fToBind = this, \n        fNOP = function () {},\n        fBound = function () {\n          return fToBind.apply(this instanceof fNOP\n                                 ? this\n                                 : oThis,\n                               aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n\n    return fBound;\n  };\n}\n\n/**\n * DEPRECATED. Old js.io polyfills.\n */\n\nvar SLICE = Array.prototype.slice;\n\n/* Use native isArray if available\n */\nif (typeof Array.isArray === 'function') {\n\texports.isArray = Array.isArray;\n} else {\n\texports.isArray = function (obj) {\n\t\treturn Object.prototype.toString.call(obj) === '[object Array]';\n\t}\n}\n\nexports.bind = function(context, method /*, VARGS*/) {\n\tif(arguments.length > 2) {\n\t\tvar args = SLICE.call(arguments, 2);\n\t\treturn typeof method == 'string'\n\t\t\t? function __bound() {\n\t\t\t\tif (context[method]) {\n\t\t\t\t\treturn context[method].apply(context, args.concat(SLICE.call(arguments, 0)));\n\t\t\t\t} else {\n\t\t\t\t\tthrow logger.error('No method:', method, 'for context', context);\n\t\t\t\t}\n\t\t\t}\n\t\t\t: function __bound() { return method.apply(context, args.concat(SLICE.call(arguments, 0))); }\n\t} else {\n\t\treturn typeof method == 'string'\n\t\t\t? function __bound() {\n\t\t\t\tif (context[method]) {\n\t\t\t\t\treturn context[method].apply(context, arguments);\n\t\t\t\t} else {\n\t\t\t\t\tthrow logger.error('No method:', method, 'for context', context);\n\t\t\t\t}\n\t\t\t}\n\t\t\t: function __bound() { return method.apply(context, arguments); }\n\t}\n}\n\n/**\n * Class constructor.\n */\n\nexports.Class = function(name, parent, proto) {\n\treturn exports.__class__(function() { return this.init && this.init.apply(this, arguments); }, name, parent, proto);\n}\n\nexports.__class__ = function (cls, name, parent, proto) {\n\tvar clsProto = function () {};\n\tvar logger;\n\n\tif (typeof name != 'string') {\n\t\tproto = parent;\n\t\tparent = name;\n\t\tname = null;\n\t}\n\n\tif (name) {\n\t\tlogger = exports.logging.get(name);\n\t}\n\n\tif (!parent) { throw new Error('parent or prototype not provided'); }\n\tif (!proto) { proto = parent; parent = null; }\n\n\tif (parent) {\n\t\tif (exports.isArray(parent)) { // multiple inheritance, use at your own risk =)\n\t\t\tclsProto.prototype = {};\n\t\t\tfor(var i = 0, p; p = parent[i]; ++i) {\n\t\t\t\tif (p == Error && ErrorParentClass) { p = ErrorParentClass; }\n\t\t\t\tfor (var item in p.prototype) {\n\t\t\t\t\tif (!(item in clsProto.prototype)) {\n\t\t\t\t\t\tclsProto.prototype[item] = p.prototype[item];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tparent = parent[0];\n\t\t} else {\n\t\t\tif (parent == Error && ErrorParentClass) { parent = ErrorParentClass; }\n\t\t\tclsProto.prototype = parent.prototype;\n\t\t}\n\t}\n\t\n\tvar supr = parent ? function(context, method, args) {\n\t\t\tvar f = parent.prototype[method];\n\t\t\tif (!f) { throw new Error('method ' + method + ' does not exist'); }\n\t\t\treturn f.apply(context, args || []);\n\t\t} : null;\n\t\n\tvar p = cls.prototype = new clsProto();\n\tp.constructor = cls;\n\tp.__parentClass__ = parent;\n\tif (name) { p.__class__ = name; }\n\tproto.call(p, logger || supr, logger && supr);\n\treturn cls;\n}\n\nvar ErrorParentClass = exports.__class__(function ErrorCls() {\n\t\tvar err = Error.prototype.constructor.apply(this, arguments);\n\t\tfor (var prop in err) {\n\t\t\tif (err.hasOwnProperty(prop)) {\n\t\t\t\tthis[prop] = err[prop];\n\t\t\t}\n\t\t}\n\t}, function() {});\n\n/**\n * Merge two objects together.\n */\n\nexports.Class.defaults = \nexports.merge = function(base, extra) {\n\tbase = base || {};\n\t\n\tfor (var i = 1, len = arguments.length; i < len; ++i) {\n\t\tvar copyFrom = arguments[i];\n\t\tfor (var key in copyFrom) {\n\t\t\tif (copyFrom.hasOwnProperty(key) && !base.hasOwnProperty(key)) {\n\t\t\t\tbase[key] = copyFrom[key];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn base;\n}\n\n/**\n * Create a timer delay.\n */\n\nexports.delay = function(orig, timeout) {\n\tvar _timer = null;\n\tvar ctx, args;\n\tvar f = function() { orig.apply(ctx, args); }\n\treturn function() {\n\t\tctx = this;\n\t\targs = arguments;\n\t\tif (_timer) { clearTimeout(_timer); }\n\t\t_timer = setTimeout(f, timeout || 0);\n\t}\n}\n\n/**\n * Log constructor and default \"logger\".\n */\n\nexports.logging = (function() {\n\t\n\t// logging namespace, this is what is exported\n\tvar logging = {\n\t\t\tDEBUG: 1,\n\t\t\tLOG: 2,\n\t\t\tINFO: 3,\n\t\t\tWARN: 4,\n\t\t\tERROR: 5,\n\t\t\tNONE: 10\n\t\t},\n\t\tloggers = {}, // effectively globals - all loggers and a global production state\n\t\tproduction = false;\n\tvar gPrefix = '';\n\tlogging.setPrefix = function(prefix) { gPrefix = prefix + ' '; }\n\tlogging.setProduction = function(prod) { production = !!prod; }\n\tlogging.get = function(name) {\n\t\treturn loggers.hasOwnProperty(name) ? loggers[name]\n\t\t\t: (loggers[name] = new Logger(name));\n\t}\n\tlogging.set = function(name, _logger) {\n\t\tloggers[name] = _logger;\n\t}\n\t\n\tlogging.getAll = function() { return loggers; }\n\n\tlogging.__create = function(pkg, ctx) { ctx.logger = logging.get(pkg); }\n\t\n\tvar Logger = exports.__class__(\n\t\tfunction Logger(name, level) {\n\t\t\tthis._name = name;\n\t\t\tthis._level = level || logging.LOG;\n\t\t},\n\t\tfunction () {\n\t\t\tthis.setLevel = function(level) { this._level = level; }\n\t\t\n\t\t\tfunction makeLogFunction(level, type) {\n\t\t\t\treturn function() {\n\t\t\t\t\tif (!production && level >= this._level) {\n\t\t\t\t\t\tvar prefix = type + ' ' + gPrefix + this._name,\n\t\t\t\t\t\t\tlistener = this._listener || exports.log;\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn listener && listener.apply(this._listener, [prefix].concat(SLICE.call(arguments)));\n\t\t\t\t\t}\n\t\t\t\t\treturn arguments[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tthis.setListener = function(listener) { this._listener = listener; }\n\t\t\tthis.debug = makeLogFunction(logging.DEBUG, \"DEBUG\");\n\t\t\tthis.log = makeLogFunction(logging.LOG, \"LOG\");\n\t\t\tthis.info = makeLogFunction(logging.INFO, \"INFO\");\n\t\t\tthis.warn = makeLogFunction(logging.WARN, \"WARN\");\n\t\t\tthis.error = makeLogFunction(logging.ERROR, \"ERROR\");\n\t\t});\n\n\treturn logging;\n})();\n\nvar logger = exports.logging.get('jsiocore');\n"},"sdk/gc/browser/bootstrap/launchBrowser.js":{"path":"sdk/gc/browser/bootstrap/launchBrowser.js","friendlyPath":"gc.browser.bootstrap.launchBrowser","directory":"sdk/gc/browser/bootstrap/","filename":"launchBrowser.js","baseMod":"gc","basePath":"sdk/","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// this file bootstraps the loading screen in a web browser\n\njsio(\"import .renderer\");\njsio(\"import lib.Callback\");\n\nvar MAX_FPS = 15;\nvar PAUSE_DURATION = 250;\nvar FADE_DURATION = 500;\nvar TEST_INVITE = false;\n\nvar delegate;\nvar callDelegate = function(f) { if (delegate[f]) { return delegate[f].apply(delegate, Array.prototype.slice.call(arguments, 1)); }};\n\n// Setup\nvar controller = CONFIG.preload || {};\nvar d = document;\nvar el = d.body.appendChild(d.createElement('canvas'));\n\n// some android phones mock out html5 objects, but don't implement them\nvar ctx = el.getContext && el.getContext('2d');\n\n// Fill the screen\nel.style.cssText = 'position:absolute; background:' + (controller.color || 'black');\n\n// Explicitly set opacity so we can easily fade the canvas out later\nel.style.opacity = 1;\nel.style.webkitTransition = 'opacity ' + FADE_DURATION + 'ms linear';\n\n// Ensure the element is above everything\nel.style.zIndex = 65534;\n\nel.onmousedown = el.ontouchstart = function (e) { callDelegate('onTap', e); e.stopPropagation(); e.preventDefault(); }\n\n// update DOM on resize\nvar onResize = function () {\n\t// resize the canvas context to fit real pixels\n\tvar width = window.innerWidth;\n\tvar height = window.innerHeight;\n\n\tif (el.width != width || el.height != height) {\n\t\tel.width = width;\n\t\tel.height = height;\n\n\t\tel.style.width = width + 'px';\n\t\tel.style.height = height + 'px';\n\n\t\trenderer.setOpts(callDelegate, ctx, width, height);\n\t\tcallDelegate('onResize');\n\t\trenderer.render();\n\t}\n};\n\ncontroller.render = function () { renderer.render(); }\n\ncontroller.startTick = function () {\n\tthis._interval = setInterval(bind(controller, 'onTick'), 1000 / MAX_FPS);\n}\n\ncontroller.onTick = function () {\n\tcallDelegate('onTick');\n\tthis.render();\n}\n\ncontroller.show = function () {\n\tcallDelegate('onBeforeShow');\n\n\tonResize();\n\twindow.addEventListener('resize', onResize, false);\n\twindow.addEventListener('orientationchange', onResize, false);\n\n\td.body.appendChild(el);\n\n\tif (!el.style.opacity) {\n\t\tel.style.opacity = 1;\n\t\tsetTimeout(bind(this, callDelegate, 'onShow'), FADE_DURATION);\n\t} else {\n\t\tcallDelegate('onShow');\n\t}\n};\n\nvar onHide = new lib.Callback();\n\n// This is called automatically when the app is ready unless autoHide === false\ncontroller.hide = function (cb) {\n\n\tonHide.run(cb);\n\n\tif (!callDelegate('onBeforeHide')) {\n\n\t\tonHide.fire();\n\t\tonHide.reset();\n\n\t\tsetTimeout(bind(this, function () {\n\t\t\tel.style.opacity = 0;\n\t\t\tsetTimeout(bind(this, function() {\n\t\t\t\twindow.removeEventListener('resize', onResize, false);\n\t\t\t\twindow.removeEventListener('orientationchange', onResize, false);\n\t\t\t\td.body.removeChild(el);\n\t\t\t\t\n\t\t\t\tif (this._interval) { clearInterval(this._interval); }\n\t\t\t\tcallDelegate('onHide');\n\t\t\t}, FADE_DURATION));\n\t\t}), PAUSE_DURATION);\n\t}\n};\n\ncontroller.onAppLoadError = function (error) {\n\tcallDelegate('onAppLoadError', error);\n};\n\nif (jsio.__jsio.__srcCache['./src/LoadingDelegate.js']) {\n\tjsio(\"import src.LoadingDelegate as LoadingDelegate\");\n\tdelegate = new LoadingDelegate();\n} else {\n\tdelegate = {\n\t\tinit: function () {\n\t\t\t// default background image\n\t\t\tif (controller.img) {\n\t\t\t\tjsio(\"import .ImageView\");\n\t\t\t\tnew loader.ImageView({\n\t\t\t\t\timage: controller.img,\n\t\t\t\t\tscaleMethod: controller.scaleMethod,\n\t\t\t\t\talign: controller.imgAlign,\n\t\t\t\t\tverticalAlign: controller.imgVerticalAlign\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tcontroller.show();\n\t\t}\n\t}\n}\n\ncallDelegate('onLoad', controller);\n\nonResize();\n\nsetTimeout(function () {\n\twindow._continueLoad();\n}, 100);","pre":true},"sdk/gc/browser/bootstrap/renderer.js":{"path":"sdk/gc/browser/bootstrap/renderer.js","friendlyPath":".renderer","directory":"sdk/gc/browser/bootstrap/","filename":"renderer.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nRenderer=__class__;var Renderer=Renderer(function Renderer(){return this.init&&this.init.apply(this,arguments)},function () {\n\tthis.init = function () {\n\t\tthis._views = [];\n\t}\n\n\tthis.add = function (view) {\n\t\tthis._views.push(view);\n\t\tthis.render();\n\t}\n\n\tthis.setOpts = function (delegate, ctx, width, height) {\n\t\tthis._delegate = delegate;\n\t\tthis._ctx = ctx;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tvar canvas = ctx.canvas;\n\t\tcanvas.width = this.width;\n\t\tcanvas.height = this.height;\n\t}\n\t\n\tthis.render = function () {\n\t\t// some android phones mock out html5 objects, but don't implement them\n\t\tvar ctx = this._ctx;\n\t\tif (!ctx) { return; }\n\n\t\t// clear the canvas with clear rect\n\t\tvar canvas = ctx.canvas;\n\t\tctx.clearRect(0, 0, canvas.width, canvas.height);\n\n\t\tctx.save();\n\t\tfor (var i = 0, v; v = this._views[i]; ++i) {\n\t\t\tv.render(ctx);\n\t\t}\n\n\t\tthis._delegate('onRender', ctx);\n\t\tctx.restore();\n\t};\n});\n\nexports = new Renderer();\n\n\t// // Display name\n\t// if (displayName) {\n\t// \tvar r = preload.displayName;\n\t\t\n\t// \tctx.fillStyle = preload.textColor || 'black';\n\t// \tctx.textAlign = 'center';\n\t// \tctx.verticalAlign = 'middle';\n\t// \tctx.textBaseline = 'middle';\n\t// \tctx.font = 'bold 24px \"Droid Sans\", Helvetica';\n\t// \tctx.fillText(displayName.toUpperCase(), r.x + r.w/2, r.y + r.h/2);\n\t// }\n\n\t// // Photo\n\t// if (photoImgReady) {\n\t// \tvar r = preload.photo;\n\t// \tctx.drawImage(photoImg, r.x, r.y, r.w, r.h);\n\t// }\n","pre":true},"sdk/jsio/lib/Callback.js":{"path":"sdk/jsio/lib/Callback.js","friendlyPath":"lib.Callback","directory":"sdk/jsio/lib/","filename":"Callback.js","baseMod":"lib","basePath":"sdk/jsio","src":"var sdk_jsio_lib_Callback=__class__;exports=sdk_jsio_lib_Callback(function sdk_jsio_lib_Callback(){return this.init&&this.init.apply(this,arguments)},function() {\n\n\tthis._fired = false;\n\tthis._id = 0;\n\tthis._pending = null;\n\n\tthis.init = function() { this._run = []; };\n\t\n\t/* fired is @deprecated in favor of hasFired*/\n\tthis.hasFired = this.fired = function() { return this._fired; } ;\n\n\t// preserve pending callbacks, but clear fired status\n\tthis.reset = function() { this._args = []; this._fired = false; };\n\n\t// clear fired status and remove any pending callbacks\n\tthis.clear = function() { this.reset(); this._run = []; this._pending = null; this._stat = null; };\n\n\t// a convenience function to proxy arguments to `this.run`: arguments passed as the first argument\n\tthis.forward = function(args) { this.run.apply(this, args); };\n\n\t// when the lib.Callback object fires, run a ctx, method, and\n\t// (optional) curried arguments or a single callback function\n\tthis.run = function(ctx, method) {\n\t\tvar f = method ? bind.apply(this, arguments) : ctx;\n\t\tif (f) {\n\t\t\tif (this._fired) {\n\t\t\t\tf.apply(this, this._args);\n\t\t\t} else {\n\t\t\t\tthis._run.push(f);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.runOrTimeout = function(onFire, onTimeout, duration) {\n\t\tif (!onFire && !onTimeout) { return; }\n\n\t\tif (this._fired) {\n\t\t\tonFire.apply(this, this._args);\n\t\t} else {\n\t\t\tvar f = bind(this, function() {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\tonFire.apply(this, this._args);\n\t\t\t});\n\n\t\t\tthis.run(f);\n\n\t\t\tvar timeout = setTimeout(bind(this, function() {\n\t\t\t\tfor (var i = 0, n = this._run.length; i < n; ++i) {\n\t\t\t\t\tif (this._run[i] == f) {\n\t\t\t\t\t\tthis._run.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tonTimeout();\n\t\t\t}), duration);\n\t\t}\n\t};\n\n\tthis.fire = function() {\n\t\tif (this._fired) { return; }\n\t\tthis._fired = true;\n\n\t\tvar cbs = this._run;\n\t\tthis._args = arguments;\n\t\tfor(var i = 0, len = cbs.length; i < len; ++i) {\n\t\t\tif (cbs[i]) { cbs[i].apply(this, arguments); }\n\t\t}\n\t};\n\n\tthis.chain = function(id) {\n\t\tif (!this._pending) { this._pending = {}; }\n\t\tif (id === undefined) { id = this._id++; }\n\t\tthis._pending[id] = true;\n\n\t\tthis.reset();\n\t\treturn bind(this, '_deferred', id);\n\t};\n\n\tthis._deferred = function(id) {\n\t\tif (!this._stat) { this._stat = {}; }\n\t\tif (this._stat.hasOwnProperty(id)) { return; }\n\n\t\tthis._stat[id] = Array.prototype.slice.call(arguments, 1);\n\t\tvar pending = this._pending;\n\t\tdelete pending[id];\n\t\tfor (var id in pending) {\n\t\t\tif (pending.hasOwnProperty(id)) { return; }\n\t\t}\n\n\t\tthis.fire(this._stat);\n\t};\n});\n","pre":true},"sdk/gc/browser/bootstrap/ImageView.js":{"path":"sdk/gc/browser/bootstrap/ImageView.js","friendlyPath":".ImageView","directory":"sdk/gc/browser/bootstrap/","filename":"ImageView.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\njsio(\"import .renderer\");\n\nvar sdk_gc_browser_bootstrap_ImageView=__class__;exports=sdk_gc_browser_bootstrap_ImageView(function sdk_gc_browser_bootstrap_ImageView(){return this.init&&this.init.apply(this,arguments)},function (supr) {\n\n\tthis.init = function(opts) {\n\t\tif (!opts) { opts = {}; }\n\n\t\tthis.x = opts.x || 0;\n\t\tthis.y = opts.y || 0;\n\t\tthis.width = opts.width || 0;\n\t\tthis.height = opts.height || 0;\n\n\t\tthis._scaleMethod = opts.scaleMethod || 'stretch';\n\t\tthis.setImage(opts.image);\n\n\t\tthis._verticalAlign = opts.verticalAlign;\n\t\tthis._align = opts.align;\n\n\t\tthis._onload = opts.onload;\n\n\t\tif (opts.sourceSlices && opts.destSlices) {\n\t\t\tthis._sourceSlices = opts.sourceSlices;\n\t\t\tthis._destSlices = opts.destSlices;\n\t\t\tthis._sourceSlicesHor = [opts.sourceSlices.hor.left, opts.sourceSlices.hor.center, opts.sourceSlices.hor.right];\n\t\t\tthis._sourceSlicesVer = [opts.sourceSlices.ver.top, opts.sourceSlices.ver.middle, opts.sourceSlices.ver.bottom];\n\t\t\tthis._destSlicesHor = [opts.destSlices.hor.left, 0, opts.destSlices.hor.right];\n\t\t\tthis._destSlicesVer = [opts.destSlices.ver.top, 0, opts.destSlices.ver.bottom];\n\t\t\tthis._checkBounds = true;\n\t\t}\n\n\t\tthis.computePosition();\n\t\trenderer.add(this);\n\t}\n\n\tthis.getImage = function() { return this._img; }\n\tthis.setImage = function(img) {\n\t\tif (typeof img == 'string') {\n\t\t\tthis._img = new Image();\n\t\t\tthis._img.onload = bind(this, function () {\n\t\t\t\tthis._onload && this._onload(this);\n\t\t\t\trenderer.render();\n\t\t\t});\n\n\t\t\tthis._img.src = img;\n\t\t} else {\n\t\t\tthis._img = img;\n\t\t}\n\t}\n\n\tthis.computePosition = function () {\n\t\tvar w = this.width || renderer.width;\n\t\tvar h = this.height || renderer.height;\n\n\t\tvar iw = this._img.width;\n\t\tvar ih = this._img.height;\n\n\t\tif (!this._img.complete) { return false; }\n\n\t\tswitch (this._scaleMethod) {\n\t\t\tcase 'none':\n\t\t\t\treturn {x: 0, y: 0, width: iw, height: ih, scale: 1};\n\t\t\tcase 'stretch':\n\t\t\t\treturn {x: 0, y: 0, width: w, height: h};\n\t\t\tcase 'contain':\n\t\t\tcase 'cover':\n\t\t\tdefault:\n\t\t\t\tvar scale = 1;\n\t\t\t\tvar targetRatio = iw / ih;\n\t\t\t\tvar ratio = w / h;\n\t\t\t\tif (this._scaleMethod == 'cover' ? ratio > targetRatio : ratio < targetRatio) {\n\t\t\t\t\tscale = w / iw;\n\t\t\t\t} else {\n\t\t\t\t\tscale = h / ih;\n\t\t\t\t}\n\t\t\t\tvar finalWidth = iw * scale;\n\t\t\t\tvar finalHeight = ih * scale;\n\t\t\t\tvar x = this._align == 'left' ? 0 : this._align == 'right' ? w - finalWidth : (w - finalWidth) / 2;\n\t\t\t\tvar y = this._verticalAlign == 'top' ? 0 : this._verticalAlign == 'bottom' ? h - finalHeight : (h - finalHeight) / 2;\n\t\t\t\treturn {x: x, y: y, width: finalWidth, height: finalHeight, scale: scale};\n\t\t}\n\t}\n\t\n\tthis.render = function(ctx) {\n\t\tif (!this._img || !this._img.complete) { return; }\n\t\t\n\t\tctx.save();\n\t\ttry {\n\t\t\tctx.translate(this.x, this.y);\n\n\t\t\tif (this._scaleMethod === '9slice') {\n\t\t\t\tvar debugColors = ['#FF0000', '#00FF00', '#0000FF'];\n\t\t\t\tvar image = this._img;\n\t\t\t\tvar bounds = { width:this._img.width, height: this._img.height};\n\t\t\t\tvar sourceSlicesHor = this._sourceSlicesHor;\n\t\t\t\tvar sourceSlicesVer = this._sourceSlicesVer;\n\t\t\t\tvar destSlicesHor = [];\n\t\t\t\tvar destSlicesVer = [];\n\t\t\t\tvar width = this.width || renderer.width;\n\t\t\t\tvar height = this.height || renderer.height;\n\t\t\t\tvar scale = 1;\n\t\t\t\tvar sx, sy, sw, sh;\n\t\t\t\tvar dx, dy, dw, dh;\n\t\t\t\tvar i, j;\n\n\t\t\t\tif ((bounds.width <= 0) || (bounds.height <= 0)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (this._checkBounds) {\n\t\t\t\t\tthis._checkBounds = false;\n\t\t\t\t\tsw = 0;\n\t\t\t\t\tsh = 0;\n\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\tsw += sourceSlicesHor[i];\n\t\t\t\t\t\tsh += sourceSlicesVer[i];\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\tsourceSlicesHor[i] = (sourceSlicesHor[i] * bounds.width / sw) | 0;\n\t\t\t\t\t\tsourceSlicesVer[i] = (sourceSlicesVer[i] * bounds.height / sh) | 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdestSlicesHor[0] = this._destSlicesHor[0] * scale | 0;\n\t\t\t\tdestSlicesHor[2] = this._destSlicesHor[2] * scale | 0;\n\t\t\t\tdestSlicesHor[1] = width - destSlicesHor[0] - destSlicesHor[2];\n\n\t\t\t\tdestSlicesVer[0] = this._destSlicesVer[0] * scale | 0;\n\t\t\t\tdestSlicesVer[2] = this._destSlicesVer[2] * scale | 0;\n\t\t\t\tdestSlicesVer[1] = height - destSlicesVer[0] - destSlicesVer[2];\n\n\t\t\t\tsy = 0;\n\t\t\t\tdy = 0;\n\t\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\t\tsh = sourceSlicesVer[j];\n\t\t\t\t\tdh = destSlicesVer[j];\n\t\t\t\t\tsx = 0;\n\t\t\t\t\tdx = 0;\n\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\tsw = sourceSlicesHor[i];\n\t\t\t\t\t\tdw = destSlicesHor[i];\n\t\t\t\t\t\tif ((dw > 0) && (dh > 0)) {\n\t\t\t\t\t\t\tctx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);\n\t\t\t\t\t\t\tif (this.debug) {\n\t\t\t\t\t\t\t\tctx.strokeStyle = debugColors[(j + i) % 3];\n\t\t\t\t\t\t\t\tctx.strokeRect(dx + 0.5, dy + 0.5, dw - 1, dh - 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsx += sw;\n\t\t\t\t\t\tdx += dw;\n\t\t\t\t\t}\n\t\t\t\t\tsy += sh;\n\t\t\t\t\tdy += dh;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tvar pos = this.computePosition();\n\t\t\t\tif (pos) {\n\t\t\t\t\tctx.drawImage(this._img, pos.x, pos.y, pos.width, pos.height);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\n\t\t} finally {\n\t\t\tctx.restore();\n\t\t}\n\n\t}\n});\n","pre":true}});</script></html>